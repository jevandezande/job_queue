#!/usr/bin/env python3

import os
import re
from subprocess import check_call
from sq import SQParser, setup_cluster


parser = SQParser()
parser.add_argument('-O', '--old', help='Request old version.',
                    action='store_true', default=False)
args = parser.parse_args()

cluster = setup_cluster(args)

cwd = os.getcwd()
orca_path = '/opt/orca' if args.old else '/opt/orca_current'
mpi_path = '/opt/openmpi_1.10.2/bin'
mpi_lib = '/opt/openmpi_1.10.2/lib'

queue = cluster.queue

inp = args.input
if not os.path.exists(inp):
    raise Exception('Unable to find input file')
inp_root = '.'.join(inp.split('.')[:-1])

output = args.output
if output == '{autoselect}':
    output = 'output.dat' if inp == 'input.dat' else inp_root + '.out'
output = f'{cwd}/{output}'

# If not defined, name the job after the directory
name = cwd.split('/')[-1] if args.name == '{autoselect}' else args.name
# Job name can't start with a number
if name.isdigit():
    name = 'J' + name

# Set the number of processors to that in input file, else 1
nodes = args.nodes
nprocs_re = r'%\s*pal\n?\s*nprocs\s+(\d+)\n?\s*end'
with open(inp) as f:
    res = re.search(nprocs_re, f.read())
nprocs = int(res.group(1)) if res else 1
if nprocs % nodes:
    raise Exception(f'Cannot divide {nprocs} processes evenly between {nodes} nodes.')
ppn = int(nprocs/nodes)


# TODO: remove hardcode
error_file = 'error'
qsubopt = ''
user = 'vandezande'
moinp_files_array = ''
xyz_files_array = ''


sub_file = f"""#!/bin/zsh
#PBS -S /bin/zsh
#PBS -l nodes={nodes}:ppn={ppn}
#PBS -l walltime=8760:00:00
#PBS -q {queue}
#PBS -j oe
#PBS -e {error_file}
#PBS -N {name}

echo "${{PBS_JOBID:r}}: {name} - $PBS_O_WORKDIR" >> $HOME/.jobs

setopt EXTENDED_GLOB
setopt NULL_GLOB
export MKL_NUM_THREADS=1
export OMP_NUM_THREADS=1
export OMPI_MCA_btl_tcp_if_include=192.168.2.0/24

ulimit -u 8191


export PATH={mpi_path}:{orca_path}:$PBS_O_PATH

export LD_LIBRARY_PATH={mpi_lib}:/opt/intel/mkl/lib/intel64:/opt/intel/lib/intel64:$LD_LIBRARY_PATH
export RSH_COMMAND="/usr/bin/ssh -x"

# Move old output file to output.#
if [ -f {output} ]
then
    for i in {{1..1000}}
    do
        if [ ! -f {output}.$i ]
        then
            mv {output} {output}.$i
            break
        fi
    done
fi


mkdir -p /scratch/{user}
tdir=$(mktemp -d /scratch/{user}/{inp_root}__XXXXXX)
export LD_LIBRARY_PATH=$tdir/orca:$LD_LIBRARY_PATH

foreach node ($(sort -u $PBS_NODEFILE)) {{
    ssh $node "mkdir -p $tdir && cp -r {orca_path} $tdir/orca"
}}

# Setup for helper applications...
# For NBO 6.0:
export NBOEXE=$tdir/orca/nbo6.exe
export GENEXE=$tdir/orca/gennbo.exe

export PATH=$tdir/orca:{mpi_path}:$PATH

# Function to delete unnecessary files
cleanup () {{
    # Delete the ORCA executable
    foreach node ($(sort -u $PBS_NODEFILE)) {{
        ssh $node "rm -rf $tdir/orca"
    }}
    # Copy the important stuff
    cp -v ^(*.(tmp*|out|inp))  $PBS_O_WORKDIR/ >>& {output}
    #cp -v {inp_root}.asa.inp  $PBS_O_WORKDIR/ >>& {output}

    # Delete everything in the temporary directory
    foreach node ($(sort -u $PBS_NODEFILE)) {{ ssh $node "rm -rf $tdir" }}
}}

trap '
echo "Job terminated from outer space!" >> {output}
cleanup
echo "${{PBS_JOBID:r}}: {name} - $PBS_O_WORKDIR" >> $HOME/.failed_jobs
exit
' TERM


cp $PBS_O_WORKDIR/{inp_root}.* $tdir/

cd $PBS_O_WORKDIR
foreach file ({moinp_files_array} {xyz_files_array} *.pc *.opt *.hess *.rrhess *.bas *.pot *.rno *.LJ *.LJ.Excl)
  cp -v $file $tdir/ >>& {output}
end

cd $tdir

num_nodes=$(wc -l $PBS_NODEFILE | cut -d " " -f 1)
echo "Start: $(date)" >> {output}
echo "Job running on $PBS_O_HOST, running $(which orca) copied from {orca_path} on $(hostname) in $tdir" >> {output}
echo "Shared library path: $LD_LIBRARY_PATH" >> {output}
echo "PBS Job ID $PBS_JOBID is running on $num_nodes nodes:" >> {output}
cat $PBS_NODEFILE | tr "\\n" ", " |  sed "s|,$|\\n|" >> {output}

# = calls full path in zsh
=orca {inp} >>& {output}

cleanup


echo "${{PBS_JOBID:r}}: {name} - $PBS_O_WORKDIR" >> $HOME/.completed_jobs
"""


with open(f'{inp_root}.zsh', 'w') as f:
    f.write(sub_file)

if not args.debug:
    check_call(f'qsub {qsubopt} {inp_root}.zsh', shell=True)
